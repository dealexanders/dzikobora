<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dzikobora - Online Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0f172a;
            font-family: 'Inter', system-ui, sans-serif;
            touch-action: none;
            overflow: hidden;
        }
        
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }
        
        .dpad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 2px;
            width: 120px;
            height: 120px;
        }
        
        .dpad-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        .dpad-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }
        
        .dpad-up { grid-column: 2; grid-row: 1; }
        .dpad-left { grid-column: 1; grid-row: 2; }
        .dpad-center { grid-column: 2; grid-row: 2; background: transparent; border: none; }
        .dpad-right { grid-column: 3; grid-row: 2; }
        .dpad-down { grid-column: 2; grid-row: 3; }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }
        
        @media (min-width: 769px) {
            .mobile-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Dzikobora v0.2 — roles + SFX
        // Actor = user, Enemy = dzik, Loot = trufle
        // Controls: WASD / Arrow Keys. P to pause. R to restart. M to mute.

        const WIDTH = 900;
        const HEIGHT = 600;
        const USER_SIZE = 64;
        const USER_SPEED = 3.2;
        const TRUFFLE_SIZE = 40;
        const DZIK_SIZE = 40;
        const STARTING_LIVES = 3;
        const ROUND_TIME = 60; // seconds

        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function rand(min, max) { return Math.random() * (max - min) + min; }
        function dist(a, b) { const dx = a.x - b.x; const dy = a.y - b.y; return Math.hypot(dx, dy); }

        function spawnNonOverlapping(existing, size, padding = 16) {
          let x, y; let tries = 0;
          do {
            x = rand(size + padding, WIDTH - size - padding);
            y = rand(size + padding, HEIGHT - size - padding);
            tries++;
            if (tries > 200) break;
          } while (existing.some(o => dist(o, {x, y}) < (o.size || USER_SIZE) + size + padding));
          return { x, y };
        }

        function DzikoboraGame() {
          const canvasRef = useRef(null);
          const [running, setRunning] = useState(false);
          const [paused, setPaused] = useState(false);
          const [muted, setMuted] = useState(false);
          const [score, setScore] = useState(0);
          const [lives, setLives] = useState(STARTING_LIVES);
          const [timeLeft, setTimeLeft] = useState(ROUND_TIME);
          const [message, setMessage] = useState("Zbieraj trufle, unikaj dzików!");

          const keys = useRef(new Set());
          const user = useRef({ x: WIDTH/2, y: HEIGHT/2, size: USER_SIZE, facingRight: true });
          const trufle = useRef([]);
          const dziki = useRef([]);
          const lastTime = useRef(0);
          const stepAccum = useRef(0);
          const [isMobile, setIsMobile] = useState(false);

          // Sprite images
          const [sprites, setSprites] = useState({
            player: null,
            dzik: null,
            truffle: null,
            tree: null
          });

          // Detect mobile device
          useEffect(() => {
            const checkMobile = () => {
              setIsMobile(window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
            };
            checkMobile();
            window.addEventListener('resize', checkMobile);
            return () => window.removeEventListener('resize', checkMobile);
          }, []);

          // Load sprites and audio
          useEffect(() => {
            const loadAssets = async () => {
              try {
                // Load images
                const playerImg = new Image();
                const dzikImg = new Image();
                const truffleImg = new Image();
                const treeImg = new Image();
                
                // Load custom PNG sprites
                playerImg.src = 'player.png';
                dzikImg.src = 'dzik.png';
                truffleImg.src = 'truffle.png';
                treeImg.src = 'tree.png';
                
                // Load audio files
                const pigSquealAudio = new Audio('pigsqueal.mp3');
                const appleBiteAudio = new Audio('applebite.mp3');
                
                // Wait for all images to load
                await Promise.all([
                  new Promise((resolve) => { playerImg.onload = resolve; }),
                  new Promise((resolve) => { dzikImg.onload = resolve; }),
                  new Promise((resolve) => { truffleImg.onload = resolve; }),
                  new Promise((resolve) => { treeImg.onload = resolve; })
                ]);
                
                // Wait for audio to be ready
                await Promise.all([
                  new Promise((resolve) => { 
                    pigSquealAudio.addEventListener('canplaythrough', resolve, { once: true });
                    pigSquealAudio.load();
                  }),
                  new Promise((resolve) => { 
                    appleBiteAudio.addEventListener('canplaythrough', resolve, { once: true });
                    appleBiteAudio.load();
                  })
                ]);
                
                setSprites({
                  player: playerImg,
                  dzik: dzikImg,
                  truffle: truffleImg,
                  tree: treeImg
                });
                
                setAudioFiles({
                  pigSqueal: pigSquealAudio,
                  appleBite: appleBiteAudio
                });
              } catch (error) {
                console.error('Error loading assets:', error);
              }
            };
            
            loadAssets();
          }, []);

          // --- Audio ---
          const audioCtxRef = useRef(null);
          const masterGainRef = useRef(null);
          const [audioFiles, setAudioFiles] = useState({
            pigSqueal: null,
            appleBite: null
          });

          function ensureAudio() {
            if (!audioCtxRef.current) {
              const ctx = new (window.AudioContext || window.webkitAudioContext)();
              const master = ctx.createGain();
              master.gain.value = muted ? 0 : 0.6;
              master.connect(ctx.destination);
              audioCtxRef.current = ctx;
              masterGainRef.current = master;
            }
          }

          useEffect(() => {
            // reflect mute state in gain
            if (masterGainRef.current) masterGainRef.current.gain.value = muted ? 0 : 0.6;
          }, [muted]);

          function playFootstep() {
            if (!audioCtxRef.current || muted) return;
            const ctx = audioCtxRef.current;
            const dur = 0.09;
            const noise = ctx.createBufferSource();
            const buffer = ctx.createBuffer(1, ctx.sampleRate * dur, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = (Math.random()*2-1) * Math.exp(-i/data.length*4);
            noise.buffer = buffer;
            const bp = ctx.createBiquadFilter();
            bp.type = "bandpass"; bp.frequency.value = 220; bp.Q.value = 1.2;
            const gain = ctx.createGain();
            gain.gain.value = 0.25;
            noise.connect(bp); bp.connect(gain); gain.connect(masterGainRef.current);
            noise.start();
          }

          function playBite() {
            if (muted || !audioFiles.appleBite) return;
            audioFiles.appleBite.currentTime = 0;
            audioFiles.appleBite.volume = 0.6;
            audioFiles.appleBite.play().catch(e => console.log('Audio play failed:', e));
          }

          function playSqueal() {
            if (muted || !audioFiles.pigSqueal) return;
            audioFiles.pigSqueal.currentTime = 0;
            audioFiles.pigSqueal.volume = 0.6;
            audioFiles.pigSqueal.play().catch(e => console.log('Audio play failed:', e));
          }

          // Mobile control functions
          const handleMobileKey = (key, isPressed) => {
            if (isPressed) {
              keys.current.add(key);
            } else {
              keys.current.delete(key);
            }
          };

          // Setup keyboard and touch events
          useEffect(() => {
            const down = (e) => {
              const k = e.key.toLowerCase();
              keys.current.add(k);
              if (k === "p") togglePause();
              if (k === "r") reset();
              if (k === "m") setMuted(m => !m);
            };
            const up = (e) => { keys.current.delete(e.key.toLowerCase()); };
            
            // Touch event handlers
            const handleTouchStart = (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvasRef.current.getBoundingClientRect();
              const x = touch.clientX - rect.left;
              const y = touch.clientY - rect.top;
              
              // Simple touch controls - tap to move towards touch point
              const dx = x - user.current.x;
              const dy = y - user.current.y;
              const distance = Math.hypot(dx, dy);
              
              if (distance > 10) {
                const vx = dx / distance;
                const vy = dy / distance;
                
                // Set movement keys based on direction
                if (Math.abs(vx) > Math.abs(vy)) {
                  if (vx > 0) {
                    keys.current.add('d');
                    keys.current.delete('a');
                  } else {
                    keys.current.add('a');
                    keys.current.delete('d');
                  }
                } else {
                  if (vy > 0) {
                    keys.current.add('s');
                    keys.current.delete('w');
                  } else {
                    keys.current.add('w');
                    keys.current.delete('s');
                  }
                }
              }
            };
            
            const handleTouchEnd = (e) => {
              e.preventDefault();
              // Clear all movement keys on touch end
              keys.current.delete('w');
              keys.current.delete('a');
              keys.current.delete('s');
              keys.current.delete('d');
            };
            
            window.addEventListener("keydown", down);
            window.addEventListener("keyup", up);
            
            if (canvasRef.current) {
              canvasRef.current.addEventListener("touchstart", handleTouchStart, { passive: false });
              canvasRef.current.addEventListener("touchend", handleTouchEnd, { passive: false });
            }
            
            return () => { 
              window.removeEventListener("keydown", down); 
              window.removeEventListener("keyup", up);
              if (canvasRef.current) {
                canvasRef.current.removeEventListener("touchstart", handleTouchStart);
                canvasRef.current.removeEventListener("touchend", handleTouchEnd);
              }
            };
          }, []);

          function start() {
            if (running) return;
            reset();
            ensureAudio();
            // Some browsers need a user gesture to resume
            audioCtxRef.current?.resume?.();
            setRunning(true);
            setPaused(false);
            setMessage("Start! Zbieraj trufle.");
          }

          function togglePause() {
            if (!running) return;
            setPaused(p => !p);
            setMessage(m => (paused ? "Start!" : "Pauza"));
          }

          function reset() {
            setScore(0); setLives(STARTING_LIVES); setTimeLeft(ROUND_TIME);
            user.current = { x: WIDTH/2, y: HEIGHT/2, size: USER_SIZE };
            trufle.current = [];
            dziki.current = [];
            for (let i=0;i<8;i++) trufle.current.push({ ...spawnNonOverlapping(trufle.current, TRUFFLE_SIZE), size: TRUFFLE_SIZE });
            for (let i=0;i<4;i++) dziki.current.push(spawnDzik());
            setRunning(false); setPaused(false);
            stepAccum.current = 0;
            setMessage("Zbierz 8 trufli i przetrwaj 60s.");
          }

          function spawnDzik() {
            const { x, y } = spawnNonOverlapping([...trufle.current, user.current], DZIK_SIZE, 24);
            const speed = rand(1.2, 2.0);
            const dir = Math.random() * Math.PI * 2;
            return { x, y, size: DZIK_SIZE, vx: Math.cos(dir)*speed, vy: Math.sin(dir)*speed, t: 0, facingRight: Math.cos(dir) >= 0 };
          }

          // Game loop
          useEffect(() => {
            const ctx = canvasRef.current?.getContext("2d");
            let raf;

            const loop = (ts) => {
              if (!ctx) return;
              if (!lastTime.current) lastTime.current = ts;
              const dt = Math.min(0.033, (ts - lastTime.current) / 1000); // clamp delta
              lastTime.current = ts;

              // Update
              if (running && !paused) {
                // timer
                setTimeLeft(t => {
                  const nt = Math.max(0, t - dt);
                  if (nt === 0) {
                    endGame("Koniec czasu! 🎉");
                  }
                  return nt;
                });

                // user move
                const p = user.current;
                const up = keys.current.has("arrowup") || keys.current.has("w");
                const down = keys.current.has("arrowdown") || keys.current.has("s");
                const left = keys.current.has("arrowleft") || keys.current.has("a");
                const right = keys.current.has("arrowright") || keys.current.has("d");
                let vx = (right?1:0) - (left?1:0);
                let vy = (down?1:0) - (up?1:0);
                const mag = Math.hypot(vx, vy);
                const norm = mag || 1;
                
                // Update facing direction based on horizontal movement
                if (vx > 0) p.facingRight = true;
                else if (vx < 0) p.facingRight = false;
                
                p.x = clamp(p.x + (vx/norm)*USER_SPEED*60*dt, p.size, WIDTH - p.size);
                p.y = clamp(p.y + (vy/norm)*USER_SPEED*60*dt, p.size, HEIGHT - p.size);

                // footsteps cadence (only when moving)
                const moving = mag > 0;
                if (moving) {
                  stepAccum.current += dt;
                  const stepInterval = 0.28 / (1 + 0.12*mag); // a bit faster when moving diagonally
                  if (stepAccum.current >= stepInterval) {
                    playFootstep();
                    stepAccum.current = 0;
                  }
                } else {
                  stepAccum.current = 0; // reset when standing
                }

                // dziki wander + steer toward user occasionally
                dziki.current.forEach(b => {
                  b.t += dt;
                  const steerChance = 0.015; // small chance per frame to re-aim
                  if (Math.random() < steerChance) {
                    const ang = Math.atan2(p.y - b.y, p.x - b.x) + rand(-0.8, 0.8);
                    const sp = Math.hypot(b.vx, b.vy) || rand(1.2, 2.0);
                    b.vx = Math.cos(ang) * sp;
                    b.vy = Math.sin(ang) * sp;
                  }
                  b.x += b.vx * 60 * dt;
                  b.y += b.vy * 60 * dt;
                  if (b.x < b.size || b.x > WIDTH - b.size) b.vx *= -1;
                  if (b.y < b.size || b.y > HEIGHT - b.size) b.vy *= -1;
                  
                  // Update facing direction based on horizontal movement
                  if (b.vx > 0) b.facingRight = true;
                  else if (b.vx < 0) b.facingRight = false;
                });

                // collisions: trufle
                trufle.current = trufle.current.filter(tr => {
                  if (dist(user.current, tr) < user.current.size + tr.size) {
                    playBite();
                    setScore(s => s + 10);
                    return false;
                  }
                  return true;
                });
                while (trufle.current.length < 8) {
                  trufle.current.push({ ...spawnNonOverlapping([...trufle.current, ...dziki.current, user.current], TRUFFLE_SIZE), size: TRUFFLE_SIZE });
                }

                // collisions: dziki
                for (let i = 0; i < dziki.current.length; i++) {
                  const b = dziki.current[i];
                  if (dist(user.current, b) < user.current.size + b.size - 6) {
                    // hit!
                    playSqueal();
                    setLives(L => {
                      const n = L - 1;
                      if (n <= 0) endGame("Dzik cię dopadł! 💥");
                      return n;
                    });
                    // knock back
                    user.current.x = WIDTH/2; user.current.y = HEIGHT/2;
                  }
                }
              }

              // Draw
              ctx.clearRect(0,0,WIDTH,HEIGHT);

              // background
              const grd = ctx.createLinearGradient(0,0,0,HEIGHT);
              grd.addColorStop(0, "#185a37");
              grd.addColorStop(1, "#0d3b26");
              ctx.fillStyle = grd; ctx.fillRect(0,0,WIDTH,HEIGHT);

              // grid
              ctx.strokeStyle = "rgba(255,255,255,0.06)";
              ctx.lineWidth = 1;
              for (let x=0; x<WIDTH; x+=30) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
              for (let y=0; y<HEIGHT; y+=30) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(y,HEIGHT); ctx.stroke(); }

              // trufle (using sprites)
              trufle.current.forEach(tr => {
                if (sprites.truffle) {
                  ctx.drawImage(sprites.truffle, tr.x - tr.size/2, tr.y - tr.size/2, tr.size, tr.size);
                } else {
                  // Fallback to original drawing
                  ctx.beginPath();
                  ctx.fillStyle = "#6b3f2a";
                  ctx.arc(tr.x, tr.y, tr.size, 0, Math.PI*2);
                  ctx.fill();
                }
              });

              // dziki (using sprites)
              dziki.current.forEach(b => {
                if (sprites.dzik) {
                  ctx.save();
                  if (!b.facingRight) {
                    // Flip horizontally by scaling and translating
                    ctx.scale(-1, 1);
                    ctx.drawImage(sprites.dzik, -(b.x + b.size/2), b.y - b.size/2, b.size, b.size);
                  } else {
                    ctx.drawImage(sprites.dzik, b.x - b.size/2, b.y - b.size/2, b.size, b.size);
                  }
                  ctx.restore();
                } else {
                  // Fallback to original drawing
                  ctx.fillStyle = "#5a3e36";
                  ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill();
                }
              });

              // user (using sprite)
              const p = user.current;
              if (sprites.player) {
                ctx.save();
                if (!p.facingRight) {
                  // Flip horizontally by scaling and translating
                  ctx.scale(-1, 1);
                  ctx.drawImage(sprites.player, -(p.x + p.size/2), p.y - p.size/2, p.size, p.size);
                } else {
                  ctx.drawImage(sprites.player, p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                }
                ctx.restore();
              } else {
                // Fallback to original drawing
                ctx.fillStyle = "#ffdd33";
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = "#f6b700"; ctx.lineWidth = 3; ctx.stroke();
              }

              // UI overlay text
              ctx.fillStyle = "#ffffff"; ctx.font = "16px Inter, system-ui, sans-serif";
              ctx.fillText(`Wynik: ${score}`, 14, 22);
              ctx.fillText(`Życia: ${lives}`, 140, 22);
              ctx.fillText(`Czas: ${Math.ceil(timeLeft)}`, 240, 22);

              // message
              if (!running) {
                drawCenterText(ctx, "DZIKOBORA", 56, 0, -40);
                drawCenterText(ctx, "Zbieraj trufle. Unikaj dzików.", 20, 0, 0);
                drawCenterText(ctx, "START — WASD/Strzałki, P pauza, R restart, M dźwięk", 16, 0, 34);
              } else if (paused) {
                drawCenterText(ctx, "PAUZA", 44, 0, 0);
              }

              raf = requestAnimationFrame(loop);
            };

            raf = requestAnimationFrame(loop);
            return () => cancelAnimationFrame(raf);
          }, [running, paused, score, lives, timeLeft, muted]);

          function drawCenterText(ctx, text, size, dx=0, dy=0) {
            ctx.fillStyle = "rgba(0,0,0,0.35)"; ctx.font = `bold ${size}px Inter, system-ui`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, WIDTH/2 + 2 + dx, HEIGHT/2 + 2 + dy);
            ctx.fillStyle = "#ffffff"; ctx.fillText(text, WIDTH/2 + dx, HEIGHT/2 + dy);
          }

          function endGame(reason) {
            setRunning(false); setPaused(false);
            setMessage(`${reason} Wynik końcowy: ${score}`);
          }

          return (
            <div className="w-full h-full flex items-center justify-center p-4 bg-neutral-900 text-white">
              <div className="w-full max-w-[1000px]">
                <div className="flex items-center justify-between mb-3">
                  <h1 className="text-2xl font-bold">Dzikobora v0.2</h1>
                  <div className="flex gap-2">
                    <button onClick={start} className="px-3 py-1.5 rounded-2xl bg-emerald-600 hover:bg-emerald-500 transition">Start</button>
                    <button onClick={togglePause} className="px-3 py-1.5 rounded-2xl bg-amber-600 hover:bg-amber-500 transition" disabled={!running}>{paused ? "Wznów" : "Pauza"}</button>
                    <button onClick={() => setMuted(m => !m)} className="px-3 py-1.5 rounded-2xl bg-sky-700 hover:bg-sky-600 transition">{muted ? "Wyciszony" : "Dźwięk"}</button>
                    <button onClick={reset} className="px-3 py-1.5 rounded-2xl bg-slate-700 hover:bg-slate-600 transition">Reset</button>
                  </div>
                </div>
                <div className="rounded-2xl overflow-hidden shadow-2xl ring-1 ring-white/10">
                  <canvas ref={canvasRef} width={WIDTH} height={HEIGHT} className="block w-full h-auto bg-[#0e4029]" />
                </div>
                <div className="mt-3 text-sm text-white/80">{message}</div>
                <div className="mt-4 text-xs text-white/60">
                  SFX: kroki podczas ruchu, chrupnięcie jabłka przy trufli, kwik dzika przy trafieniu. (WebAudio, bez assetów.)
                </div>
                
                {/* Mobile Controls */}
                {isMobile && (
                  <div className="mobile-controls">
                    <div className="dpad">
                      <button 
                        className="dpad-btn dpad-up"
                        onTouchStart={() => handleMobileKey('w', true)}
                        onTouchEnd={() => handleMobileKey('w', false)}
                        onMouseDown={() => handleMobileKey('w', true)}
                        onMouseUp={() => handleMobileKey('w', false)}
                        onMouseLeave={() => handleMobileKey('w', false)}
                      >
                        ↑
                      </button>
                      <button 
                        className="dpad-btn dpad-left"
                        onTouchStart={() => handleMobileKey('a', true)}
                        onTouchEnd={() => handleMobileKey('a', false)}
                        onMouseDown={() => handleMobileKey('a', true)}
                        onMouseUp={() => handleMobileKey('a', false)}
                        onMouseLeave={() => handleMobileKey('a', false)}
                      >
                        ←
                      </button>
                      <div className="dpad-center"></div>
                      <button 
                        className="dpad-btn dpad-right"
                        onTouchStart={() => handleMobileKey('d', true)}
                        onTouchEnd={() => handleMobileKey('d', false)}
                        onMouseDown={() => handleMobileKey('d', true)}
                        onMouseUp={() => handleMobileKey('d', false)}
                        onMouseLeave={() => handleMobileKey('d', false)}
                      >
                        →
                      </button>
                      <button 
                        className="dpad-btn dpad-down"
                        onTouchStart={() => handleMobileKey('s', true)}
                        onTouchEnd={() => handleMobileKey('s', false)}
                        onMouseDown={() => handleMobileKey('s', true)}
                        onMouseUp={() => handleMobileKey('s', false)}
                        onMouseLeave={() => handleMobileKey('s', false)}
                      >
                        ↓
                      </button>
                    </div>
                    
                    <button 
                      className="mobile-btn"
                      onTouchStart={() => togglePause()}
                      onMouseDown={() => togglePause()}
                    >
                      {paused ? "▶" : "⏸"}
                    </button>
                    
                    <button 
                      className="mobile-btn"
                      onTouchStart={() => setMuted(m => !m)}
                      onMouseDown={() => setMuted(m => !m)}
                    >
                      {muted ? "🔇" : "🔊"}
                    </button>
                  </div>
                )}
              </div>
            </div>
          );
        }

        // Render the game
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DzikoboraGame />);
    </script>
</body>
</html>
